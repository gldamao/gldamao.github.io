---
layout: post
title: "Chapter.23 重访For表达式"
date: 2015-06-30 21:06:02 +0800
comments: true
categories: scala 读书笔记
---

### for循环的解析
先来看一个需求的两种不同实现,找出列表中所有妈妈和孩子结对的名称.

``` scala
case class Person(name: String, isMale: Boolean, children: Person*)

val lara = Person("Lara", false)
val bob = Person("Bob", true)
val julie = Person("Julie", false, lara, bob)

val persons = List(lara, bob, julie)

val s = persons.filter(p => !p.isMale) flatMap(p => p.children map (c => (p.name,c.name)))
- - - 
for {
  p <- persons
  if (!p.isMale)
  c <- p.children
} yield (p.name, c.name)

```
Scala编译器会把第二种实现方式的代码转译成地一个.*所有的能够yield(产生)结果的for表达式都会被编译器转译为高阶方法map, flatMap及filter的组合调用.所有不带yield的for循环都会被转译为仅对高阶函数filter和foreach的调用.*
看一个更复杂一点的N皇后问题

``` scala
def queens(n: Int): List[List[(Int, Int)]] = {
  def p3333laceQueens(k: Int): List[List[(Int, Int)]] =
    if (k == 0)
      List(List())
    else
      for {
        queens <- placeQueens(k - 1)
        column <- 1 to n
        queen = (k, column)
        if isSafe(queen, queens)
      } yield queen :: queens

  placeQueens(n)
}

def isSafe(queen: (Int, Int), queens: List[(Int, Int)]) = queens forall (q => !inCheck(queen, q))

def inCheck(q1: (Int, Int), q2: (Int, Int)) =
  q1._1 == q2._1 || 
  q1._2 == q2._2 ||
  (q1._1 - q2._1).abs == (q1._2 - q2._2).abs
```

* 检验某两个点是否可以兼容放置皇后的isCheck方法.
  1. 不能用同行皇后.
  2. 不能有同列皇后.
  3. 不能有同对脚线皇后.(两个点的横纵坐标之差相等表示两者在一条对脚线上)
* isSafe方法用来检测某个点对之前所有的皇后位置组合进行测试.
* 对于k皇后问题,利用递归回溯的策略,先解决k-1皇后问题,用k-1皇后的全体解组合来与第k个皇后放置列位置进行验证.
* 对列位置从1到n依次进行验证,如果合格就返回一种组合方案.

- - - - -
####给列表去重的一段代码
其中最后一行代码可以用注释掉的for来代替

``` scala
def removeDuplicates[A](xs:List[A]): List[A] = {
  if (xs.isEmpty) xs
  else
    xs.head :: removeDuplicates(
      xs.tail filter(x=> x!= xs.head)
      // for (x <- xs.tail if x != xs.head) yield x
    )
}
```
- - - - - 

###for表达式的转译
每个for表达式都可以用三个高阶函数map, flatMap和filter来表达.
####转译带一个生成器的for表达式
```for(x <- expr1) yield expr2``` 可以转译成 ``` expr1.map(x => expr2)```

####转译以生成器和过滤器开始的for表达式
```for (x <- expr1 filter (x => expr2)) yield expr3``` 可以转译成 ```expr1 filter (x => expr2) map(x => expr3)```

####转译以两个生成器开始的for表达式

* seq是任意序列的生成器,定义及过滤器.
* seq也可能是空的,这是偶seq前的分号就可以省略了.

``` for(x <- expr1; y <- expr2; seq) yield expr3```  可以转译成 ```expr1.flatMap(x => for (y <- expr2;seq) yield expr3 )```

两 个生成器的转译例子,需求是找出写过两本书以上的作者:
``` scala
for {
  b1 <- books
  b2 <- books
  if b1 != b2
  a1 <- b1.authors
  a2 <- b2.authors
  if a1 == a2
} yield a1

//可以被转译为如下表达式

books.flatMap(b1 => 
  (books fliter (b2 => b1 != b2) flatMap(b2 =>
    b1.authors flatMap(a1 => 
      b2 filter (a2 => a1 == a2) map (a2 =>
        a1))))

```
- - -

####转译生成器中的元组和模式
如果生成器的左侧带有模式(直接生成一种模式的做法)或元素而不是简单的变量,情况就会稍微复杂一些
```for((x1, x2, x3, ..., xn) <- expr1) yield expr2```可以转译成```expr1.match { case(x1, x2, x3, ..., xn) => expr2 }```

``` scala
for(pat <- expr1) yield expr2
//会被转译为
expr1 filter {
  case pat => true
  case _ => false
} map (
  case pat => expr2
)
```
**生成器的条目首先经过过滤,保留匹配pat模式的元素,进而保证了模式匹配生成器不会抛出MatchError异常**.

####for中带有定义的转移
``` scala
for( x<- expr1; y = expr2; seq) yield expr3
//可以被转译为

for ((x, y) <- for(x <- expr1);seq) yield (x, expr2); seq)
yield expr3 
```

*每次产生新的x值时expr2都会被重新计算,防止expr2可能引用了x来改变自身的值,从而单独更新x的值会造成数值差异.*但是如果在生成器中定义了某些与循环无的变量则会大大降低运行效率,因为每次都会更新这个并不受循环新值x影响的变量.的变量则会大大降低运行效率,因为每次都会更新这个并不受循环新值x影响的变量.

- - - 

####转译无生成器的for
```for(x <- expr1) body``` 可转译为 ``` expr1.foreach(x => bdoy)```


``` scala
for (x <- expr1; if expr2; y <- expr3) body
//可转译为 
expr1.filter(x => expr2) foreach(x => 
  expr3 foreach (y => body)) 
```

1. 由expr1中经过filter生成了expr3(由符合expr2条件的x构成).
2. 接下来又把每一个expr3中的元素应用到body方法上.
