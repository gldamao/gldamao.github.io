---
layout: post
title: "Chapter.15 样本类和模式匹配"
date: 2015-05-31 16:54:59 +0800
comments: true
categories: scala 读书笔记
---

#### 样本类自动添加的属性,方法和功能
1. 首先会添加与类名一致的工厂方法.省略冗长的new关键字.
2. 样本类的参数列表中所有参数隐含获取了val前缀,会在样本类内部自动生成相应字段(普通类的参数要加上val字段才能被自动生成类内属性).
3. 编译器会为样本类自动添加*hashCode, toString, equals*三个方法的缺省实现.其中equals方法是可以进行结构化比较.
4. 最方便的是样本类支持模式匹配功能.

#### 模式匹配
* 通配模式, (_)一半用作最后一种default的匹配.
* 常量模式:任何字面值都可以作为常量.
* 变量模式:可以匹配任意对象,会把变量绑定到匹配的对象上.
* 构造器模式:对```case BinOp("*", e, Number(0)) => println("a deep match")```这种形式进行匹配.
* 序列模式:可以支持指定模式内任意数量的元素.也可以匹配不指定长度的序列.

```Scala
expr match {
  case List(0,_ ,_) => println("found it!")
  case _ => 
}

expr match {
  case List(0, _*) => println("found it!")
  case _ => 
}
```

* 元组模式:匹配元组同时可以把元组拆解.
* 类型模式:同时也可以在类型匹配后利用if语句做进一步的匹配(模式守卫).另外类型匹配可以融合类型测试和类型转换为一体,这两个操作在Scala当中是比较繁琐的.
* **变量绑定**:非常有用的功能,相当于把变量模式与其他模式进行了组合, 变量名 + @ + 模式.这种做法的意义在于它能像通常的那样做模式匹配同时如果匹配成功又可以把变量设置成匹配的对象.

```Scala
expr match {
  case Unop("abs", e @ UnOp("abs", _)) => e
  case _ => 
}
```


* 模式守卫: 模式变量(并不是变量模式)仅允许在模式中出现一次,可以通过模式守卫来丰富匹配规则.

```Scala
def simplifyAdd(e: Expr) = e match {
  case BinOp("+",x, y) if x == y =>
    BinOp("*", x, Number(2))
  case _ => e
}
```

模式本身的功能非常强大,还可以支持如下几种:

* 模式还可以用来解构一些对象或元组等数据结构.

```Scala
val exp = new BinOp("+", Number(5), Number(1))
val BinOp(op, left, right) = exp
```

> 函数体样本,花括号内的样本序列(备选项)可以用在能够出现函数字面量的任何地方.**实际上样本序列就是函数字面量**.函数字面量只有一个入口点和参数列表,而样本序列可以有多个入口点,同时每个入口点拥有自己独特的参数列表.

```Scala
val withDefault: Option[Int] => Int = {
  case Some(x) => x
  case None => 0
}
```
上述这种情况在Actor库中使用的非常频繁.
**定义了一个val的函数字面值,接下来用函数体样本来完善函数体,里面提供了多个函数入口.这样就可以生成出不同种的多个函数了,具体执行的哪个入口是要通过对参数进行模式匹配来得出的**.

* 用作偏函数的样本序列,可以用来检查偏函数是否被定义. 偏函数有一个isDefinedAt方法,可以用来测试函数是否对某个特定值有定义.

```Scala
val second: List[Int] => Int = {
  case x :: y :: _ => y
}

val secondPartial: PartialFunction[List[Int], Int] = {
  case x :: y :: _ => y
}

```

#### 类型擦除:同java一样,scala在运行期不保存类型参数信息,**对于map等需要类型参数信息的匹配只能精确到是某种任意类型的map.唯一特殊的类型是数组,在Scala和java当中数组都被特殊处理了,数组元素类型和数组值保存在一起,因此数组可以用来做模式匹配.**

```Scala
//这么做是存在问题的,类型被擦除了
def isIntMap(x: Any) = x match {
  case m: Map[Int, Int] => true
  case _ => false
}

def isStringArray(x: Any) = x match {
  case a: Array[String] => "yes"
  case _ => "No"
}
```
####封闭类 sealed class
封闭类可以保证在超类定义文件之外的任何地点不能再添加子类.例如在模式匹配中无法保证有一个合理的default处理,一般来说这是不可能的,因为新的样本类可以定义在任何时刻和任何位置,而无法保证目前设定的模式匹配逻辑对于新定义样本类也是"合理合法的".
而如果使用封闭类,把所有子样本类都限定在超类定义的文件中,就可以focus在已知的样本类上.**同时如果使用继承自封闭类的样本类做匹配,编译器可以通过警告信息标识出缺失的模式组合.** 不能再赞有没有!!!
如果在明确目的的情况下可能要让编译器对于部分为做匹配的模式警告闭嘴,可以采用通配模式并抛出一个RuntimeException(为了以防万一)或为选择起的表达式加上注解.

```scala
def describe(e: Expr):String = (e: @unchecked) match { .....}
```

####option 可选值
option包含了两种形式的值,Some(x)和None,其中x是实际的值,None表示缺失.分离可选值最好的方式就是采用模式匹配来处理.

