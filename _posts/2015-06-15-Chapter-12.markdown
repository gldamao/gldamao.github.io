---
layout: post
title: "Chapter.12 特质"
date: 2015-05-31 16:54:59 +0800
comments: true
categories: scala 读书笔记
---

###特质 trait

特质的定义除了关键字的差异之外,其他都和类定义无异.(如果特质没有声明超类,那么就有一个缺省的超类AnyRef),特质和java中的接口很类似,只不过特质中可以包含具体的方法.
混入特质的两种方式:

1. 使用extends关键字混入特质,**这种情况下已经隐式的继承了特质的超类**.
2. 使用with关键字混入特质.

特质与类的两个明显差异:

1. 特质不能有任何的"类"参数.不能传递任何参数给特质的主构造器. //todo Section20.5 有方法可以规避该限制
2. 在类中,super是静态绑定的.而在特质中是动态绑定的.调用的实现将在每一次特质被混入到具体的类中时才被确定.这种方式实现了特质的**可堆叠的改变**特性.

####胖 vs 瘦
特质最为重要的一个用途,是丰富现有的类.把相对独立的功能追加到某一个类上.丰富接口功能,小瘦子变身大胖子.

####特质用来做可堆叠的改变
在不改变原始基类的情况下,可以增加一些细节处理上的变化.

```Scala
import scala.collection.mutable.ArrayBuffer

abstract class IntQueue {
  def get(): Int
  def put(x: Int)
}

class BasicIntQueue extends IntQueue {
  private val buf = new ArrayBuffer[Int]
  def get() = buf.remove(0)
  def put(x: Int) { buf += x }
}

trait Doubling extends IntQueue {
  abstract override def put(x: Int) { super.put(2 * x) }
}

trait Incrementing extends IntQueue {
  abstract override def put(x: Int) { super.put(x + 1) }
}

trait Filtering extends IntQueue {
  abstract override def put(x: Int) {
    if (x >= 0) super.put(x)
  }
}
```

> 特质可以继承自某个类(也就是说特质拥有了一个显式指明的超类),这表示该特质只能被混入继承自该超类的子类中.
> **在特质中的super是动态绑定的**,Doubling中super的调用将直到被混入另外一个类或特质之后有了具体的方法定义时才工作.
> 为了告诉Scala编译器我们的目的,需要在这种需求的方法前加上```abstract override```的标志.**这种组合只能出现在特质中**.
> 最右侧的特质先起作用,如果那个方法调用了super,它调用其左侧的方法.

####why trait not multiple inheritance
最重要的差别在于对super的解释:

* 多重继承中,super的调用是静态绑定,具体调用哪个方法可以在定调用发生的地方明确决定.
* 对于特质而言,super的调用是由类和被混入到类中的特质的**线性化(linearization)**所决定的.

####如何确定选用是使用特质还是抽象类

1. 如果行为不会被重用,就使用**具体类**,具体类没有可重用的行为.
2. 如果要在多个不相关的类中重用,就选用**特质**,特质可以被混入到不同的类层级当中.
3. 如果你希望在java代码中继承它,就选用**抽象类**,特质没有特别近似的java代码相对应,另外**在java中继承特质是非常笨拙的**.
4. 只含有抽象方法的特质会被直接翻译成java接口,这种情况下两者兼容性非常棒.
5. 如果要追求效率上的极致,应该更倾向于使用类.

