---
layout: post
title: "Chapter.7 内建控制结构"
date: 2015-05-31 16:54:59 +0800
comments: true
categories: scala 读书笔记
---

##等效推论(equational reasoning)
在表达式没有副作用的情况下，引入的变量等效于计算它的表达式。无论何时都可以用表达式来代替变量名。
- - - 
###循环：
* while和do while的结构和用法同中java相同，在scala中被称作循环，并不是表达式，从而也不会产生有意义的结果，结果类型是Unit。
* 一般来说使用while的的实现都可以转化为递归函数的调用。
* Unit的有且唯一的实例写作 ()，这是scala与java很不同的一点，void是没有任何实例对象的。
* scala中赋值语句的返回值始终是Unit，Unit与任何值相比较都会返回true。
同时鼓励在代码中像质疑var那样质疑while，因为一般var和while都是成对出现的。因为while不产生值。为了让程序有所改变，通常不是更新var的值就是有其他的I/O操作。
* for可以和generator结合使用，可以兼容任何种类的集合，不仅仅是数组。或者说->符号右侧的表达式必须支持foreach方法。
* for语句中可以添加过滤条件，例如：

```scala
val files = java.io.File(".").listFiles
for (file <- files if file.getName.endsWith(".scala"))
  println(file)
```

*其中过滤器的个数不受限制*，但是在过滤条件不止一个的时候在每个条件之间需要用;来进行隔离。

```scala
for (
  file <- files
  if file.isFile;
  if file.endsWith(".scala")
) println(file)
```

为了简化语法，可以用大括号来包裹发生器和过滤器，同时在有括号中放置多个 **<-** 子句就表示嵌套的循环。

```scala
val fileHere = (new java.io.File(".")).listFiles

def fileLines(file: java.io.File) = {
  scala.io.Source.fromFile(file).getLines.toList
}

def grep(pattern: String) =
  for {
    file <- fileHere
    if (file.endsWith(".scala"))
    line <- fileLines(file)
    if line.trim.matches(pattern)
  } println(file + ": " + line.trim)

grep(".*gcd.*")
```

* mid-stream（流间）变量绑定，流间变量绑定的值都是val属性（关键字可省略）
* 利用for制造新集合  ```for {子句} yield  {循环体}```

```scala
val fileHere = (new java.io.File(".")).listFiles

def fileLength(file: java.io.File) = {
  scala.io.Source.fromFile(file).getLines.toList
}

val lineLength = for {
  file <- fileHere
  if (file.getName.endsWith(".scala"))
  line <- fileLength(file)
  trimedLine = line.trim
  if trimedLine.matches(".*for.*")
} yield trimedLine.length
```
- - - 
###异常表达式的处理以及对控制流程的影响
* throw也是有结果类型的表达式。
* 把抛出的异常当作任何类型的值都是安全的，任何使用从throw返回值的尝试都不会起作用。
* throw表达式的结果类型是Nothing。
* if的一个分支计算值，另外一个分支抛出异常，那么整个if表达式的返回值就是实际计算分支的类型。
* try catch结构中使用模式匹配。在下面的例子中如果异常并不属于其中给定的两个类型，则异常会沿着调用堆栈继续向上传递。
```scala
try {
  val f = new FileReader("filename")
} catch {
  case ex: FileNotFoundException => // Handle missing file
  case ex: java.io.IOException => //Handle error I/O 
}
```
* finaly中尽量避免返回任何值，这种情况的处理方式和java有较大的差异。保证逻辑的简单。一般就是做一些资源清理的工作。

-----
###match表达式：

* match表达式的强大之处在于它可以**支持任意模式的匹配**。
* 每个case分支都隐含了break功能。
* match表达式是可以生成值的！

- - - 

###break



- - - 



