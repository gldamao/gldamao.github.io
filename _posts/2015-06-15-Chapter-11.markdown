---
layout: post
title: "Chapter.11 Scala的层级"
date: 2015-05-31 16:54:59 +0800
comments: true
categories: scala 读书笔记
---
###Scala的类层级

Any是所有类的父类,内包含toString, hashCode, ==, !=, equals等方法,其中 ==与!=是带有final属性的,所以不能重载,但是可以通过重载equals来改变==和!=的含义.实际上Scala中的相等操作==被设计成对比较类型透明的,对于值类型而言是数学或布尔相等,对于引用类型而言,则被视为继承自Object的euqals方法的别名.默认被实现为判断引用相等.如果想要强制采用引用对比,**可以使用eq和ne操作符**.
所有的内建值类型都有一个公共的父类AnyVal,在运行时表示成Java的原始值,**不能用new创造这些类的实例,这些类都被定义为final和抽象的.** 最后,Unit有且仅有一个实例,被写作().
![Scala当中的继承关系](/home/lei/Desktop/classhierarchy.png)
Scala中的AnyRef是引用类的基类.在Java平台上AnyRef实际就是类java.lang.Object的别名.在Java平台上两者是可以交换使用,但是推荐在任何地方都使用AnyRef.

底层类型:
类Null是null类型的引用;它是每个引用类型的子类,所以Null不兼容任何值类型.类Nothing在整个继承链的最底端,它是任何其他类型的子类型.**然而这个类型并没有值**.他的最主要用途是可以和其他任何类型做兼容,例如在如下的if语句中,返回值可以始终看作是Int类型.

```Scala
def error(message:String): Nothing = throw new RuntimeException(message)

def divide(x: Int, y: Int):Int = 
  if (y != 0) x / y
  else error("can't divide zero!")
```

这样即使是通过else分支返回,Nothing也是Int的子类型,所以divide整体返回Int是没有问题的.

