---
layout: post
title: "Chapter.10 组合与继承"
date: 2015-05-31 16:54:59 +0800
comments: true
categories: scala 读书笔记
---

###抽象类

抽象类之前必须有abstract类型修饰,同时如果一个类中包含了未被实现的方法,那么他就必须被声明为抽象类.显然想要实例化一个抽象类对象是不允许的.**拥有抽象成员的类必须显式的用abstract指明是抽象类**.

**无参数方法**: 对于无参数的情况下有两种定义方式. *空括号*和*省略括号*.

> 省略括号(empty-paren method): 方法本身不接受参数, 方法仅仅读取变量值并不改变变量值.这个惯例支持统一访问原则(uniform access principle),*选用字段还是方法来实现属性,不应该影响到客户端代码.* 在性能上字段应该会比方法稍稍快一些,字段值在类初始化时预计算,而方法是在每次调用的时候都重新计算.
> 空括号: 如果方法调用中发生了I/O,或者修改了某些var变量,那么最好还是加上一对空括号.
> **简单的总结一下可以归纳为,如果方法调用没有副作用,推荐省略括号,否则最好加上一对空括号. 如果调用的函数执行了操作,就使用括号.如果仅仅提供对某个属性的访问,就省略括号.**

###重载方法和字段

在Scala中与java很大的一个区别是**字段和方法都在同一个name space中**.如此一来字段可以很轻松的重载无参数方法.相应的在同一个类中不允许使用同一个名字来定义方法和字段.

####Scala与java的命名空间对比:

> Scala中的命名空间: **值**(字段,方法,包,单例对象)  **类型**(类,特质) 
> Java中的命名空间:**字段**,**方法**,**类型**,**包**.

####定义参数化字段

在类的继承关系当中,如果子类要通过参数来实例化父类中的某些字段,可以通过参数化字段来避免重复.


``` scala
abstract class Element {
  def contents: Array[String]
  val height = contents.length
  val width = if (height == 0) 0 else contents(0).length
}

class ArrayElement( //注意,这里是小括号
  val contents: Array[String]
) extends Element
......

class ArrayElement(x123: Array[String]) extends Element {
  val contents: Array[String] = x123
}
```

在同一个时间使用相同的名称定义参数和字段的一种简写方式,现在ArrayElement有可以通过外部访问(不能重新赋值,val)的contents字段.

**继承inheritance,重载override,实现implement**.在子类中重载的如果是抽象方法,那么这个过程也叫做实现了该方法.**当实现某个父类的方法时,可以省略override关键字.同样的规律也可以应用到定义参数化字段上.**


++操作连接两个数组,Scala中的数据被表示为Java数组,但是会支持更多的方法.同时Scala中的数据继承自类scala.Seq.


```Scala
object Element {
  private val a = "123"

  private class ArrayElement(val contents: Array[String]) extends Element

  private class LineElement(s: String) extends Element {
    override def contents: Array[String] = Array(s)
  }

  private class UniformElement(ch: Char, override val length: Int, override val width: Int) extends Element {
    val line = ch.toString * width

    def con = for {
      i <- 0 until length
    } yield line

    def contents = con.toArray
  }

  def elem(s: Array[String]): Element = new ArrayElement(s)

  def elem(c: Char, length: Int, width: Int): Element = new UniformElement(c, length, width)

  def elem(s: String): Element = new LineElement(s)

}

abstract class Element {
  def contents: Array[String]

  def length = contents.length

  def width = if (length == 0) length else contents(0).length

  def above(other: Element) = Element.elem(this.contents ++ other.contents)

  def beside(other: Element) = {

  }

  override def toString(): String = {
    contents.mkString("\n")
  }

}

println(Element.elem('a', 2, 3).toString)
```

以上这段代码演示了以上几种用法,需要注意的几点:

1. 声明与调用的顺序,要求声明或定义必须出现在调用前.
2. toString是要返回一个String类型的.
3. 在一个类内部定义带有private属性的其他类,即使可以在该类内部进行实例化也不能把引用传递到外部,除非像上面这种有继承关系的,返回父类类型给外部.
4. 伴生对象与类之间可以互相访问私有成员,但是并没有共享命名空间.



