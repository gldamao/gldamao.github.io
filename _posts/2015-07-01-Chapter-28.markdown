---
layout: post
title: "Chapter.28 scala的相等性方法浅析"
date: 2015-07-01 17:40:02 +0800
comments: true
categories: scala 读书笔记
---

### Scala与java的equals方法

> "=="在java代码当中比较的是两个变量的引用(地址/对象),如果要在java中进行值比较则需要使用equals方法.

Scala中也有"=="操作符,只不过在Scala环境中表示的是值之间的比较.用来表示对象一致性的判断方法是eq.
**Scala中,==用来表示每个类型"自然的"相等性.对于值类型而言进行值比较,对于引用类型,相当与equals.**如果要改变==的默认行为可以在自定义类型中重写equals方法(==继承自Any,并且是final的),**继承的equals方法除非被重写,默认是像java那样判断对象是否一致.**因此equals(==)默认和eq是一样的.

- - - 

###重写equals方法时的四个常见陷阱:
1. 重定义equals方法时采用了错误的方法签名.
2. 修改了equals方法但并没有同时修改hashCode.
3. 用可变字段定义equals方法.
4. 未能按同关系定义equals方法.

* equals方法接受的参数类型是Any,避免误写成自定义类型.否则在集合(范型擦除)这种范型类型中使用equals时调用的是Any里面的equals,结果就会比较诡异.一种稍稍优化的做法.

``` scala
override def equals(other: Any) = other match (
  case that: Point => this.x == that.x && this.y == that.y
  case _ => false
}
```
* 在Hash集合中进行相等性比较时,首先会根据元素的hash码分桶,例如contains检查首先决定要找的桶,然后再把给定元素同该桶中所有元素进行比较.而Any中定义的hashCode是根据已分配对象地址的某种转换.
* 关于Any中hashCode方法的契约:**如果两个对象equals方法相等,那么每一次调用hashCode方法都必须产出相同的整数结果.hashCode只能依赖equals所依赖的字段**
* 常用的hashCode方法```41 * (x + 41) + y```,同质数41进行运算,可以较为高效的获取到效果不错的hashCode方法.
* 使用var变量来定义equals方法,问题同样是出在配合集合使用时,构造对象P并加入到集合中,再改变由P的equals引用的var属性.这时P和集合中的P就"不相等"了.(已经不处在同一个hash桶,元素不可见且存在)
* equals的准则,必须对非null对象实现等同关系:
  * 必须是自反的.
  * 是对称的. x equals y 也就意味着 y equals x.
  * 它必须是可传递的. 
  * 它是一致的.对于任何非空值x和y,多次调用x.equals(y)的结果应该是一致的.
  * **对于任何非空值x, x equals null应返回false.
