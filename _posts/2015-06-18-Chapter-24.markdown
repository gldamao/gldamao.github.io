---
layout: post
title: "Chapter.24 抽取器 Extractor"
date: 2015-06-18 10:42:02 +0800
comments: true
categories: scala 读书笔记
---

##抽取器
####抽取器的来源和意义
在Scala中可以通过模式匹配(构造器模式)很方便简洁的来做数据的解构和分析,不过一直以来构造器模式还是和样本类相关联,实际当中可能会要求在在不创建关联的样本类的前提下写出类似的模式.或者更希望能够创造自己的模式类型.

例如要写一个Email地址的解析工具,代码如下:

``` Scala
def isEmail(s: String): Boolean
def domain(s: String): String
def user(s: String): String

if (isEmail(s)) println(user(s) + " AT " + domain(s))
else println("not an email address")

s match {
  case Email(user, domain) => println(user + " AT " + domain)
  case _ => println("not an email address")

```

字符串显然是无法满足上述模式匹配的要求，**抽取器可以为已存在的类型定义新模式，而这种模式不需要遵守类型的内部表达方式.**
抽取器是定义了unapply(匹配并分解值)成员方法的对象(object),也允许实现用于构建值的对偶方法apply.

``` scala
object Email {
    //注入方法,可选
    def apply(user: String, domain: String) = user + "@" + domain
    //抽取方法,必须
    def unapply(str: String): Optional[(String, String)] = {
        val parts = str split "@"
        if (parts.length == 2) Some((parts(0), parts(1))) else None
    }
}

```

> 这里还可以让Email继承Scala的函数类型,声明中的类型和Function2[String, String, String]是同意的,例如:

```object Email extends (String, String) => String ={ ... }```

抽取器由于含有了unapply而拥有了抽取的能力,于此同时也必须要考虑到传入的字符串可能并非email的情况,所以返回值**要求必须是Option和boolean(特殊情况,表示匹配成功或失败)**.
```selectorString match { case Email(user, domain) => ...}``` 将引发unapply调用
```Email.unapply(selectorString)```. 首先要判断参数是否符合unapply方法的参数类型,不符合则直接失败.

####变参抽取器
如果想要抽取不定数量的元素值,例如希望匹配代表域名的字符串,使得域的每一段都被拆分在不同的子模式中.
如下代码逆序匹配域名,参数列表尾部的序列同陪模式 _*, 匹配序列中所有剩下的元素.

``` scala
object Domain {
  def apply(parts: String*) {
    parts.reverse.mkString(".")
  }

  def unapply(whole: String): Option[Seq[String]] = {
    Some(whole.split("\\.").reverse)
  }
}

dom match {
  case Domain("org", "acm") => println("acm.org")
  case Domain("com", "sun", "java") => println("java.sun.com")
  case Domain("net", _*) => println("a .net domain")
}
```

- - - 

### 样本类和抽取器之间的区别

* **抽取器可以把客户端代码独立开,**如果不见已经定义并导出了一套样本类,那么客户端就可能已经包含了对这些样本类的模式匹配.重命名某些样本类或修改类层级都将影响到客户端代码.
* 样本类的执行效率比抽取器更高,同时拥有静态的检查.
* 如果样本类继承自sealed基类,Scala编译器将采用穷据发检查模式匹配并在模式没有覆盖某种可能的组合值情况喜爱报错.



