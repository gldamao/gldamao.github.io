---
layout: post
title: "Chapter.30 Actor和并发"
date: 2015-07-02 17:26:02 +0800
comments: true
categories: scala 读书笔记
---

### scala和java对于并发设计的不同之处

> java平台内置了基于共享内存和锁的线程模型,每个对象都关联了一个逻辑监控器,可以根据监控器来控制对数据的多线程访问.

对于将要被多线程共享的数据标记为*synchronized*来保证java runtime将应用一种锁机制来确保同一时间只有一个线程进入由同一个锁控制的同步代码段,以此来在多进程之间协同数据访问.

然而这种模型导致的问题就是控制复杂,编写代码时必须知道当下要申请哪些锁资源,以及正在修改或访问的数据可能会被其他线程修改或访问.频繁的锁操作以及竞争资源导致性能的大幅度下降.还有可能导致死锁.

Scala的actor提供了一种不共享任何数据,依赖消息传递的模型来实现并发.避免死锁.从根本上绕开了**共享数据+锁**所引入的问题.

#### actor和消息传递
actor当中的几个概念:

* 信箱: actor中接收并暂存发送给它的消息的空间.每个actor的信箱是独立的.
* 独立执行: actor是是一个类似线程的实体,每个actor使用一个独立的线程.
* actor的生命周期: 
  1. act方法返回.
  2. act方法由于异常被终止.
  3. actor调用exit方法.
* 消息投递是异步的,任何逻辑都不应依赖于消息到达信箱的顺序.
* 信箱中在receive方法被调用时如果没有消息,则该调用会阻塞,直到有消息抵达.
* 如果信箱中没有任何消息可以被偏函数处理,则对receive方法的调用也会阻塞,直到一个可以匹配的消息抵达.(为防止邮箱被沾满,需要有一个case _ 语句来处理任意的消息)

当actor发送消息是并不会组合,同样接收消息时也不会被打断,消息在邮箱中等待被处理.直到actor调用receive方法(每次处理一条消息).receive调用预先定义好的偏函数.

actor处理传给receive方法的片函数中的某个样本匹配的消息.邮箱中的每一个消息都要先调用传入片函数的isDefinedAt方法来决定是否与某个样本匹配.

####native thread vs actor

1. 如果使用的显示定义的actor则无需关心它和线程的对应关系是怎样的.Actor子系统会管理一个或多个原生线程供自己使用.
2. 如果反过来把原声线程当做actor使用则不能调用Thread.current这种方法(因为并不具备),需要用Actor.self来把当前线程作为actor来查看.
3. 一般都常用在交互式的repl环境中.

- - - 

####通过重用(共享)线程获得更好的性能

actor是构建在普通的java线程之上的.**每个actor都会有一个独立的线程**.为了节约线程,scala提供了react(也带一个偏函数),react在找到并处理消息后并不返回.返回类型是Nothing.
考虑如果程序包含大量的actor,为每一个actor单独创建进程代价会很大,而且actor的大部分时间都是用于等待消息.**与其让每个actor在单独的县城中阻塞,不如用一个线程来执行多个actor的消息处理函数**.

> 由于react方法不需要返回,其实现不需要保留当前线程的调用栈.actor库可以在下一个被唤醒的线程中重用当前的线程.如果所有的actor都是react,理论上只需要一个线程就能够满足程序的全部actor的需要(如果计算机有多个core,actor子系统将在可能的情况下使用足够多的线程来充分利用所有core).

使用react避免频繁的线程切换开销.接收消息的消息处理器需要同时处理消息并执行actor所有余下的工作.

Actor线程模型可以这样理解：所有Actor共享一个线程池，总的线程个数可以配置，也可以根据CPU个数决定；当一个Actor启动之后，Scala分配一个线程给它使用，如果使用receive模型，这个线程就一直为该Actor所有，如果使用react模型，Scala执行完react方法后抛出异常，则该线程就可以被其它Actor使用。

``` scala
object LearnActor {

  def main(args: Array[String]): Unit = {

  }
}

object NameResolver extends Actor {
  override def act(): Unit = {
    react {
      case Some(host: String, actor: Actor) =>
        actor ! getIp(host)
        act()
      case "EXIT" =>
        println("Name resolver exiting.")
      case msg =>
        println("Unhandled message: " + msg)
        act()
    }
  }

  def getIp(name: String): Option[String] = {
    import java.net.{InetAddress, UnknownHostException}
    try {
      Some(InetAddress.getByName(name).toString)
    } catch {
      case _: UnknownHostException => None
    }

  }
}

// 使用loop的另一个版本

def act() {
  loop {
    react {
      case (name: String, actor: Actor) =>
        actor ! getIp(name)
      case msg =>
        println("Unhandled message: " + msg)
    }
  }
}
```

1. 不使用死循环.再执行完相应的消息处理操作后再次调用act()以此来实现持续的接收消息.
2. 如果不在case分支的最后调用act()方法,则可以把这个case分支认为是退出分支.
3. 也可以用**scala.actors.Actor.loop**函数重复执行一个代码段.这个actor将会循环相应消息,forever~~~~

eventloop方法也可以制作出一个无穷循环套react的简化版,不过要求偏函数不会再次调用react.

``` scala
def act()
  eventloop {
    case Withdraw(amount) => println("Withdrawing " + amount)
  }
```
- - - 

###看看城里人怎么写actor

* Actor不应该阻塞,否则在actor阻塞时,另一个actor可能会对它发起一个它能够处理的请求.如果actor在首个请求时阻塞了,那么它将不会留意到第二个请求.最坏的情况是多个actor都在等待另一个阻塞的actor的响应.
* react的工作原理,返回Nothing表示永远不会正常返回的函数,总是以异常的方式完成.
  * 当调用一个actor的start时,start方法会保证最终有某个线程来调用那个actor的act方法.
  * 如果act当中调用了react,则react方法会在actor的邮箱中查找传递给偏函数的能够处理的消息.如果找到可处理消息,react会在卫莱某个时间处理该消息并在完成后抛出异常.
  * 如果找不到符合偏函数(isDefinedAt方法)的消息,会把actor置于"冷存储"状态,再下次邮箱收到更多消息时重新激活,并抛出异常.随之act方法也结束,调用act的线程会catch这个异常,忽略这个actor,并继续处理其他事务.
* 只通过消息与actor通信,如果一个Actor把指向自己的引用作为消息的一部分发给了另外一个Actor,那么强烈要求在下游Actor中除了通过!向其发送消息外,不通过引用主动调用任何方法.
* 通过创建一个"拥有"可变映射的actor并定义一系列允许其他actor访问这个映射的消息.来在多个actor中共享一份可变映射.这是比较actor style的做法,另外也可以通过消息向多个actor传递一个线程安全的映射(ConcurrentHashMap).让这些actor直接使用那个映射.
* 优先选择发送不可变的消息,每个actor的act方法都工作在单线程环境中,可以在act方法中使用任何非同步,可变的对象.但是用于在actor间发送消息的对象中的数据由多个actor"共享".

###同步消息和Future
####三种发送消息的方式:
1. ! 直接发送,异步请求.
2. !? 发送同步请求并等待处理结果的返回.
3. !! 发送请求并接收一个future(一个将在结果可用时产出结果的对象)

- - -
#**actor模式不建议使用同步请求,可能会造成死锁或大幅度降低应用性能**

1. 上游发送方会被自动的赋值给sender变量.
2. 也可以使用reply(some message to deliver)来回传消息.
3. 通过对future的函数调用表示法可以取回结果.**该操作可能会被阻塞,直到回复被发送**.(可以用isSet方法来检测结果是否已经可用.)
4. future的优势在于可以把结果一直传递下去,直到真正需要取出返回值的时候.

