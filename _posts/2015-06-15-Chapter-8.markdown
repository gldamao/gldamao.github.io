---
layout: post
title: "Chapter.8 函数和闭包"
date: 2015-05-31 16:54:59 +0800
comments: true
categories: scala 读书笔记
---

###本地方法
Scala中允许在一个方法内进行其他方法的定义，被包含的方法就叫做本地方法，**本地方法可以访问包含他们的方法的参数**。
一般本地方法是用来进行命名空间的隔离，功能相对独立和系统的Help方法可以考虑写成本地方法。
place holder: 被运行时传入的参数所代替，占位符需要足够的信息来明确自己将来要被什么类型的数据所代替，例如 _ + _ 是不合法的表达式。可以通过指定类型来改进上述表达式 (_:Int) + (_:Int) 
一个表达式中可以出现多个占位符，他们表达的意思是**有多个参数需要替换，而不是一个参数的多次替换**。

##偏应用函数（Partially applied function）
Scala的世界中，当带哦用函数时，传入任何需要的参数，就叫做把函数应用到参数上。而偏应用函数是一种表达式，不要求提供函数所需要的所有参数，仅仅给出其中一部分或者根本不提供所需参数。例如：
```Scala
scala > val a = sum _ 
a: (Int, Int , Int) => Int = <function>
```
对于上述代码，Scala编译器会片应用函数表达式 sum _ , 实例化一个*带三个缺失整形参数*的**函数值**，并赋值给变量a。当把新的到的函数值a应用到三个参数上时，就会去调用sum并传入这三个参数。

实际上变量a指向一个由Scala编译器依照偏应用函数表达式sum _ ，而实例化的一个函数值对象（实例），编译器生成的类中包含了一个apply方法，该方法的参数个数同sum _ 表达式缺少的参数数量。so... Scala编译器把表达式a(1, 2, 3)翻译成对函数值的apply方法调用并传入三个参数1, 2, 3. 所以上述调用就被转换为：

```Scala
scala> a.apply(1, 2, 3)
res1: Int = 6
```

以上这种一个下划线代表了全部参数列表的表达式的另一种用途，就是把它当作转化def为函数值的方式。

**尽管不能把方法或嵌套函数复制给变量或当作参数传递给其他方法，但是如果你把方法或嵌套函数通过在名称后面加一个下划线的方式包装在函数值中，就可以做到了。**

如果一个忽略所有参数的偏应用表达式，且代码在那个地方正需要一个函数，那就可以去掉下划线而另表达更简明。例如：```someNumbers.foreach(println _)```可以写成```someNumbers.foreach(println)``` 后一种格式仅在需要写函数的地方，**foreach需要一个函数作为参数传入。**如果在不需要函数的情况下， 尝试使用这种格式将引发一个编译错误。

> 注意：Scala需要制定显示省略的函数参数，尽管简单到只用一个‘_’。Scala仅允许在需要函数类型的地方才能省略这个'_'。

###闭包 Closure
通过“捕获”自由变量的绑定对函数文本执行的“关闭”行动。
针对闭包引出两个概念：

1. 封闭术语(closed term)： 在函数编写的时候就已经封闭了，没有任何带有自由变量的函数文本。
2. 开放术语(open term)： 在运行期间创建的函数值必须不或某些自由变量并绑定。

如果在闭包被创建之后，被封闭的元素发生了变化。Scala依然能够捕获到变化，可以说Scala封闭的是变量本身，而不是the value of variable。

如果闭包访问了某些在程序运行时有若干不同备份的变量时，在创建闭包的时刻活跃的值将会被封闭。

###重复参数
Scala支持方法的**最后一个参数**被指定为重复参数。只需在参数的类型后加一个“星号”。

```Scala
scala> def echo(args: String*) = 
	for (arg <- args) println(arg)
```
在方法内部是把重复参数的类型当作声明参数类型的数组来处理。*在作为参数时是**多个**,**重复**,**独立**的参数*，而在方法内部是Array[T]类型，所以如果想在参数调用时传递Array，则需要把Array元素展开：

```Scala
scala> echo(arr: _*)
```
把参数类型写成 “_*”可以展开Array对象。这个标注告诉编译器把Array的每个元素当作参数依次传入，而不是当作单一的参数传入。

###尾递归(Tail recursion)
说白了就是在方法的最后再次调用该方法本身，Scala编译器检测到尾递归就用新值更新函数参数，然后把它替换成一个回到函数开头的跳转。
**道义上不应该修与使用递归算法解决问题，递归经常是比基于循环的更优美和简明的方案。如果方案是为递归，就无需付出任何运行期开销。**尾递归的追踪过程会相应的变得繁琐，不过可以通过```-g:notailcalls```参数，来关闭尾递归优化。
####尾递归的局限性
由于VJM的指令集的关系，Scala只能优化直接递归调用使其返回同一个函数。

1.如果递归是间接的，例如：

```Scala
def isEven(x: Int): Boolean = 
	if (x == 0) true else isOdd(x - 1)
def isOdd(x: Int): Boolean = 
	if (x == 0) false else isEven(x - 1)
```
2.如果最后一个调用是一个**函数值**，那么也不能获得尾递归优化。例如：

```Scala
val funValue = nestedFun _
def nestedFun(x: Int) {
	if (x != 0) { println(x); funValue(x - 1) }
}
```
funValue变量实际上指向了一个包装了nestedFun的方法调用的函数值。当把这个函数值应用到参数上（一次方法调用过程，*方法应用到参数上*），它会转向把nestedFun应用到同一个参数，并返回结果。
但是这样Scala还是受限于方法或嵌套函数在最后一个操作调用本身，而没有转到某个函数值或什么其他的中间函数的情况而不能进行尾递归优化。


> 如果方法最后都是返回自身的**函数值**调用，则永远无法进行尾递归优化，另外也不能在函数调用后再附加其他操作，只能光秃秃的做一次自身调用！！！

